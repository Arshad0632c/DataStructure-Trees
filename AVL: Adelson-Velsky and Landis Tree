AVL Tree:

#include<iostream>
using namespace std;
int height(struct AVL *temp);
struct AVL *rightrotation(struct AVL *k1);
struct AVL *leftrotation(struct AVL *k1);
struct AVL *leftrightrotation(struct AVL *k1);
struct AVL *rightleftrotation(struct AVL *k1);
struct AVL *insert(int element,struct AVL *root);
void display(struct AVL *ptr,int level);
void inorder(struct AVL *temp);
int max(int a,int b);

struct AVL
{
	int element;
	struct AVL *left;
	struct AVL *right;
	int height;
}*root=NULL;

int height(struct AVL *temp)
{
	if(temp==NULL)
		return -1;
	else
		return temp->height;
}

struct AVL *rightrotation(struct AVL *k1)
{
	struct AVL *k2;
	k2=k1->left;
	k1->left=k2->right;
	k2->right=k1;
	k1->height=max(height(k1->left),height(k1->right))+1;
	k2->height=max(height(k2->left),k1->height)+1;
	return k2;
}   
    
struct AVL *leftrotation(struct AVL *k1)
{
	struct AVL *k2;
	k2=k1->right;
	k1->right=k2->left;
	k2->left=k1;
	k1->height=max(height(k1->left),height(k1->right))+1;
	k2->height=max(height(k2->right),k1->height)+1;
	return k2;
}

struct AVL *leftrightrotation(struct AVL *k1)
{
	k1->left=leftrotation(k1->left);
	return rightrotation(k1);
}

struct AVL *rightleftrotation(struct AVL *k1)
{
	k1->right=rightrotation(k1->right);
	return leftrotation(k1);
}

struct AVL *insert(int element,struct AVL *root)
{
	if(root==NULL)
	{
		root=new AVL();
		root->element=element;
		root->height=0;
		root->left=root->right=NULL;
	}
	else if(element<root->element)
	{
		root->left=insert(element,root->left);
		if(height(root->left)-height(root->right)==2)
			if(element<root->left->element)
				root=rightrotation(root);
			else
				root=leftrightrotation(root);
	}
	else if(element>root->element)
	{
		root->right=insert(element,root->right);
		if(height(root->left)-height(root->right)==-2)
			if(element>root->right->element)
				root=leftrotation(root);
			else
				root=rightleftrotation(root);
	}
	root->height=max(height(root->left),height(root->right))+1;
	return root;
}
void display(struct AVL *ptr,int level)
{
	int i;
	if(ptr!=NULL)
	{
		display(ptr->right,level + 1);
		cout<<endl;
		if(ptr==root)
			cout<<"root -> ";
		for(i=0;i<level && ptr != root; i++)
			cout<<"          ";
		cout<<ptr->element;
		display(ptr->left,level + 1);
	}
}
void inorder(struct AVL *temp)
{
	if (temp!=NULL)
	{
		inorder(temp->left);
		cout<<temp->element<<" ";
		inorder(temp->right);
	}
}
int max(int a,int b)
{
	if(a>b)
		return a;
	else
		return b;
}
int main()
{
	int ch,element;
	cout<<"\n AVL TREE \n Enter the operations to be performed: ";
	cout<<"\n 1.INSERTION \n 2.IN-ORDER \n 3.DISPLAY\n";
	while(1)
	{
		cout<<"\n Enter your choice:  ";
		cin>>ch;
		switch(ch)
		{
			case 1:
					cout<<"\n Enter the node to insert:  ";
					cin>>element;
					root=insert(element,root);
					break;
			case 2:
					printf("In-order Traversal: ");
					inorder(root);
					break;
			case 3:
					if(root==NULL)
					{
						printf(" The tree is empty");
						continue;
					}
					printf("\n AVL tree is:  ");
					display(root,1);
					break;
			default:printf(" \n Invalid choice");
					exit(0);
					break;
		}
	}
	return 0;
}
